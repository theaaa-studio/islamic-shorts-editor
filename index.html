<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quran Shorts ‚Äî Editor By TheAAA</title>
    <link rel="icon" type="image/x-icon" href="assets/quran.ico" />

    <!-- Free Google Fonts (original set) -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Lora:wght@400;600;700&family=Merriweather:wght@400;700&family=Nunito:wght@400;700&family=Poppins:wght@400;600;700&family=Roboto+Slab:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <!-- Additional Google Fonts (Latin) -->
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600;700&family=Source+Sans+3:wght@400;600;700&family=Work+Sans:wght@400;600;700&family=Raleway:wght@400;600;700&family=Playfair+Display:wght@400;700&family=DM+Serif+Text:ital@0;1&family=Libre+Baskerville:wght@400;700&family=Lato:wght@400;700&family=Oswald:wght@400;600;700&family=Ubuntu:wght@400;700&family=PT+Serif:wght@400;700&family=PT+Sans:wght@400;700&family=Karla:wght@400;700&family=Rubik:wght@400;700&family=Quicksand:wght@400;700&family=Heebo:wght@400;700&family=Barlow:wght@400;700&family=Manrope:wght@400;700&family=Space+Grotesk:wght@400;700&family=Space+Mono:wght@400;700&family=Fira+Sans:wght@400;700&family=Fira+Code:wght@400;700&family=JetBrains+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <!-- Additional Google Fonts (Arabic & Arabic-friendly) -->
    <link
      href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Scheherazade+New:wght@400;700&family=Cairo:wght@400;700&family=Changa:wght@400;700&family=Reem+Kufi:wght@400;700&family=Noto+Naskh+Arabic:wght@400;700&family=Noto+Kufi+Arabic:wght@400;700&family=IBM+Plex+Sans+Arabic:wght@400;700&family=Tajawal:wght@400;700&family=El+Messiri:wght@400;700&family=Markazi+Text:wght@400;700&family=Lateef&family=Harmattan:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --bg: #0b0d12;
        --panel: #0f131a;
        --panel-2: #0c1117;
        --text: #e8eef9;
        --muted: #9fb0cc;
        --line: rgba(255, 255, 255, 0.08);
        --accent-1: #7c5cff;
        --accent-2: #22d3ee;
        --radius: 16px;
        --gap: 14px;

        /* Layout split */
        --sidebar: 70%;
        --preview: 30%;

        /* Preview size */
        --previewMax: 360px;
        --previewMaxMobile: 210px;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
        background: radial-gradient(
            1200px 1200px at 10% -10%,
            rgba(124, 92, 255, 0.12),
            transparent 60%
          ),
          radial-gradient(
            1000px 1000px at 110% -10%,
            rgba(34, 211, 238, 0.1),
            transparent 55%
          ),
          var(--bg);
        color: var(--text);
      }

      .app {
        height: 100%;
        display: grid;
        grid-template-columns: var(--sidebar) var(--preview);
      }

      /* Sidebar (left 70%) */
      .sidebar {
        border-right: 1px solid var(--line);
        padding: 18px;
        display: grid;
        grid-template-rows: auto auto auto auto auto auto 1fr; /* brand, input, background, typography, credits, playback, spacer */
        gap: 16px;
        position: sticky;
        top: 0;
        height: 100vh;
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .logo {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        background: url("assets/quran.png") center/contain no-repeat;
      }
      .title {
        margin: 0;
        font-size: 16px;
        font-weight: 700;
      }
      .subtitle {
        margin: 2px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .panel {
        display: grid;
        gap: 12px;
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 14px;
        background: #0e131a;
      }
      .panel h3 {
        margin: 0 0 8px;
        font-size: 14px;
        font-weight: 700;
      }

      .field {
        display: grid;
        gap: 6px;
      }
      label.small {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .hint {
        font-size: 11px;
        color: var(--muted);
        opacity: 0.9;
      }

      /* Helpers */
      .three-col {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
      }
      .four-col-inline {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 12px;
      }
      .two-col-inline {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #0c1117;
      }
      .toggle input {
        width: 16px;
        height: 16px;
      }

      select,
      button,
      input[type="range"],
      input[type="color"],
      input[type="text"] {
        appearance: none;
        padding: 10px 12px;
        font-size: 14px;
        color: var(--text);
        background: #0c1117;
        border: 1px solid var(--line);
        border-radius: 10px;
        outline: none;
        width: 100%;
      }
      select:focus,
      input[type="range"]:focus,
      input[type="color"]:focus {
        border-color: rgba(124, 92, 255, 0.6);
        box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.15);
      }

      input[type="color"] {
        height: 48px;
        padding: 0;
        cursor: pointer;
      }
      input[type="color"]::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 8px;
      }
      input[type="color"]::-moz-color-swatch {
        border: none;
        border-radius: 8px;
      }

      input[type="range"] {
        height: 38px;
        padding: 0 2px;
        background: transparent;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--accent-1), var(--accent-2));
        opacity: 0.6;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid #cbd5e1;
        margin-top: -6px;
        box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
      }

      .btn {
        cursor: pointer;
        user-select: none;
        background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
        color: #071018;
        border: none;
        font-weight: 700;
        padding: 10px 12px;
        border-radius: 10px;
        box-shadow: 0 10px 28px rgba(124, 92, 255, 0.35);
      }
      .btn.ghost {
        background: #0c1117;
        color: var(--text);
        border: 1px solid var(--line);
        box-shadow: none;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .status {
        font-size: 12px;
        color: var(--muted);
        white-space: pre-wrap;
      }
      .meter {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        overflow: hidden;
        border: 1px solid var(--line);
      }
      .meter > span {
        display: block;
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent-1), var(--accent-2));
        transition: width 0.25s ease;
      }

      .version-info {
        text-align: center;
        margin-top: 12px;
        opacity: 0.7;
        font-size: 12px;
        color: var(--muted);
      }

      .transport {
        display: grid;
        grid-template-columns: repeat(5, auto);
        gap: 10px;
        align-items: center;
      }

      /* Preview area (right 30%) */
      .preview {
        padding: 24px;
        display: grid;
        grid-template-rows: 1fr auto;
        gap: 16px;
      }
      .preview-stage {
        display: grid;
        place-items: center;
        border: 1px dashed var(--line);
        border-radius: var(--radius);
        background: rgba(255, 255, 255, 0.02);
        min-height: 0;
      }
      #previewCanvas {
        width: min(100%, var(--previewMax));
        height: auto;
        aspect-ratio: 9 / 16;
        background: #fff;
        border-radius: 22px;
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.35);
      }
      audio {
        width: 100%;
      }

      /* Responsive */
      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
        }
        .sidebar {
          position: relative;
          height: auto;
        }
        .three-col,
        .four-col-inline,
        .two-col-inline {
          grid-template-columns: 1fr;
        }
        #previewCanvas {
          width: min(100%, var(--previewMaxMobile));
        }
      }

      /* Background panel: make everything sit on one horizontal row */
      .background-panel .inline-row {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: nowrap; /* keep single line */
        overflow-x: auto; /* allow sideways scroll if too many items */
        padding-bottom: 4px;
      }

      /* Keep each control compact on the line */
      .background-panel .inline-row .toggle,
      .background-panel .inline-row .field {
        flex: 0 0 auto;
      }

      /* Reasonable input widths so they don‚Äôt explode the row */
      .background-panel .inline-row select,
      .background-panel .inline-row input[type="color"] {
        width: 220px;
      }

      /* Nicer hint placement to the far right */
      .background-panel .inline-row .hint {
        margin-left: auto;
        white-space: nowrap;
        opacity: 0.8;
        font-size: 11px;
      }
      .preview-controls {
        display: flex;
        justify-content: center;
        gap: 12px;
      }

      /* ‚Äî‚Äî‚Äî Choose File (design only) ‚Äî‚Äî‚Äî */
      .upload-row {
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: center;
        gap: 10px 12px;
        margin-top: 8px;
      }

      .file-trigger {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: linear-gradient(
          135deg,
          rgba(124, 92, 255, 0.16),
          rgba(34, 211, 238, 0.16)
        );
        color: var(--text);
        font-weight: 700;
        cursor: pointer;
        user-select: none;
        white-space: nowrap;
        transition: transform 0.08s ease, box-shadow 0.15s ease,
          border-color 0.15s ease;
      }
      .file-trigger:hover {
        box-shadow: 0 8px 24px rgba(124, 92, 255, 0.16);
        border-color: rgba(124, 92, 255, 0.45);
      }
      .file-trigger:active {
        transform: translateY(1px);
      }

      /* small icon */
      .file-trigger svg {
        width: 18px;
        height: 18px;
        opacity: 0.9;
      }

      /* subtle helper text */
      .file-note {
        font-size: 12px;
        color: var(--muted);
      }

      /* keep the real input accessible but hidden visually */
      #bgUploadInput.visually-hidden {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <!-- LEFT: Sidebar (70%) -->
      <aside class="sidebar">
        <div class="brand">
          <div class="logo"></div>
          <div>
            <p class="title">Quran Shorts ‚Äî Editor</p>
            <p class="subtitle">Spread the message of Quran in short videos.</p>
          </div>
        </div>

        <!-- Panel: Input -->
        <div class="panel">
          <h3>Choose</h3>
          <div class="three-col">
            <div class="field">
              <label class="small" for="surah">Surah</label>
              <select id="surah"></select>
            </div>
            <div class="field">
              <label class="small" for="ayahStart">Start Ayah</label>
              <select id="ayahStart"></select>
            </div>
            <div class="field">
              <label class="small" for="ayahEnd">End Ayah</label>
              <select id="ayahEnd"></select>
            </div>
          </div>

          <div class="two-col-inline">
            <div class="field">
              <label class="small" for="reciter">Reciter (with language)</label>
              <select id="reciter">
                <option value="Abdul_Basit_Mujawwad_128kbps">
                  Abdul Basit ‚Äî Mujawwad (Arabic)
                </option>
                <option value="Alafasy_128kbps">
                  Mishary Alafasy (Arabic)
                </option>
                <option value="Husary_128kbps">
                  Mahmoud Khalil Al-Husary (Arabic)
                </option>
                <option value="Hudhaify_128kbps">
                  Ali Al-Hudhaify (Arabic)
                </option>
                <option value="Minshawi_Mujawwad_128kbps">
                  Mohamed S. El-Minshawi (Arabic)
                </option>
              </select>
            </div>

            <div class="field">
              <label class="small" for="translationEdition"
                >Translation (text) edition</label
              >
              <select id="translationEdition">
                <option value="en.asad">English ‚Äî Muhammad Asad</option>
                <option value="en.sahih">English ‚Äî Sahih International</option>
                <option value="en.pickthall">English ‚Äî Pickthall</option>
                <option value="en.yusufali">English ‚Äî Yusuf Ali</option>
                <option value="bn.bengali">
                  Bengali ‚Äî Bengali Translation
                </option>
                <option value="ur.jalandhry">
                  Urdu ‚Äî Fateh Muhammad Jalandhry
                </option>
                <option value="id.indonesian">
                  Indonesian ‚Äî Bahasa Indonesia
                </option>
                <option value="fr.hamidullah">
                  French ‚Äî Muhammad Hamidullah
                </option>
              </select>
            </div>
          </div>
        </div>

        <!-- Panel: Background -->
        <div class="panel background-panel">
          <h3>Background</h3>
          <div class="inline-row">
            <!-- Mode toggles -->
            <label class="toggle" title="Use a solid background color">
              <input
                type="radio"
                name="bgMode"
                value="color"
                id="bgModeColor"
                checked
              />
              <span>Solid Color</span>
            </label>

            <label
              class="toggle"
              title="Use image/video from assets/background"
            >
              <input
                type="radio"
                name="bgMode"
                value="media"
                id="bgModeMedia"
              />
              <span>Media (image/video)</span>
            </label>

            <!-- Solid color picker (shown when 'color' is selected) -->
            <div class="field" id="bgColorField">
              <label class="small" for="bgColor">Background Color</label>
              <input id="bgColor" type="color" value="#ffffff" />
            </div>

            <!-- Media selector (shown when 'media' is selected) -->
            <div class="field" id="bgMediaField" style="display: none">
              <label class="small" for="bgMediaSelect"
                >Choose Background (Image/Video)</label
              >
              <select id="bgMediaSelect"></select>
              <span class="hint" id="bgMediaHint"
                >Using configured media list.</span
              >

              <label
                for="bgUploadInput"
                class="file-trigger"
                title="Upload images or videos"
              >
                <!-- tiny upload icon -->
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path
                    d="M12 3v12m0 0l-4-4m4 4l4-4"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                  />
                  <path
                    d="M19 15v4a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-4"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                  />
                </svg>
                Choose files
              </label>

              <!-- keep the same ID so existing JS continues to work -->
              <input
                id="bgUploadInput"
                class="visually-hidden"
                type="file"
                accept="image/*,video/*"
                multiple
              />
            </div>
          </div>
        </div>

        <!-- Panel: Typography -->
        <div class="panel">
          <h3>Typography</h3>
          <div class="four-col-inline">
            <div class="field">
              <label class="small" for="fontPicker">Font Style</label>
              <select id="fontPicker">
                <option value="Inter, sans-serif">Inter</option>
                <option value="Poppins, sans-serif">Poppins</option>
                <option value="Lora, serif">Lora</option>
                <option value="Merriweather, serif">Merriweather</option>
                <option value="Nunito, sans-serif">Nunito</option>
                <option value="Roboto Slab, serif">Roboto Slab</option>

                <option value="Montserrat, sans-serif">Montserrat</option>
                <option value="Open Sans, sans-serif">Open Sans</option>
                <option value="Source Sans 3, sans-serif">Source Sans 3</option>
                <option value="Work Sans, sans-serif">Work Sans</option>
                <option value="Raleway, sans-serif">Raleway</option>
                <option value="Lato, sans-serif">Lato</option>
                <option value="Oswald, sans-serif">Oswald</option>
                <option value="Ubuntu, sans-serif">Ubuntu</option>
                <option value="PT Sans, sans-serif">PT Sans</option>
                <option value="Karla, sans-serif">Karla</option>
                <option value="Rubik, sans-serif">Rubik</option>
                <option value="Heebo, sans-serif">Heebo</option>
                <option value="Barlow, sans-serif">Barlow</option>
                <option value="Manrope, sans-serif">Manrope</option>
                <option value="Space Grotesk, sans-serif">Space Grotesk</option>
                <option value="Fira Sans, sans-serif">Fira Sans</option>

                <option value="Playfair Display, serif">
                  Playfair Display
                </option>
                <option value="DM Serif Text, serif">DM Serif Text</option>
                <option value="Libre Baskerville, serif">
                  Libre Baskerville
                </option>
                <option value="PT Serif, serif">PT Serif</option>

                <option value="Quicksand, sans-serif">Quicksand</option>

                <option value="Space Mono, monospace">Space Mono</option>
                <option value="Fira Code, monospace">Fira Code</option>
                <option value="JetBrains Mono, monospace">
                  JetBrains Mono
                </option>

                <option value="Amiri, serif">Amiri</option>
                <option value="Scheherazade New, serif">
                  Scheherazade New
                </option>
                <option value="Cairo, sans-serif">Cairo</option>
                <option value="Changa, sans-serif">Changa</option>
                <option value="Reem Kufi, sans-serif">Reem Kufi</option>
                <option value="Noto Naskh Arabic, serif">
                  Noto Naskh Arabic
                </option>
                <option value="Noto Kufi Arabic, sans-serif">
                  Noto Kufi Arabic
                </option>
                <option value="IBM Plex Sans Arabic, sans-serif">
                  IBM Plex Sans Arabic
                </option>
                <option value="Tajawal, sans-serif">Tajawal</option>
                <option value="El Messiri, sans-serif">El Messiri</option>
                <option value="Markazi Text, serif">Markazi Text</option>
                <option value="Lateef, serif">Lateef</option>
                <option value="Harmattan, sans-serif">Harmattan</option>
              </select>
            </div>
            <div class="field">
              <label class="small" for="textSize"
                >Font Size
                <span id="textSizeVal" class="name-chip">(100%)</span></label
              >
              <input
                id="textSize"
                type="range"
                min="25"
                max="160"
                step="5"
                value="100"
              />
            </div>
            <div class="field">
              <label class="small" for="fontColor">Font Color</label>
              <input id="fontColor" type="color" value="#111111" />
            </div>
          </div>
        </div>

        <!-- Panel: Credits -->
        <div class="panel">
          <h3>Credits</h3>
          <div class="four-col-inline">
            <div class="field">
              <label class="small" for="madeByInput">Made by (name)</label>
              <input
                id="madeByInput"
                type="text"
                placeholder="Your name or channel"
                value=""
              />
            </div>
            <label class="toggle" title="Show a Made by badge">
              <input type="checkbox" id="creditMadeBy" checked />
              <span>Made by</span>
            </label>
            <label
              class="toggle"
              title="Show attribution to data/audio providers"
            >
              <input type="checkbox" id="creditData" checked />
              <span>Data Source</span>
            </label>
            <label class="toggle" title="Show your creator tag">
              <input type="checkbox" id="creditCreator" checked />
              <span>Editor Developer</span>
            </label>
          </div>
        </div>

        <!-- Panel: Playback & Export -->
        <div class="panel">
          <h3>Playback & Export</h3>
          <div class="transport">
            <button id="buildPreviewBtn" class="btn">Play & Export</button>
            <!-- ‚úÖ ADD: Dismiss button -->
            <button id="dismissBtn" class="btn ghost" disabled>Dismiss</button>
            <button id="downloadBtn" class="btn" disabled>
              Download (WebM)
            </button>
          </div>

          <div class="two-col-inline">
            <!-- <div class="status" id="status">Ready.</div> -->
            <div class="status" id="recStatus">
              Press Play & Export to preview & auto-record. Avoid the right
              audio controller during recording.
            </div>
          </div>
          <div class="meter"><span id="meterBar"></span></div>
        </div>
      </aside>

      <!-- RIGHT: Preview (30%) -->
      <main class="preview">
        <div class="preview-stage">
          <canvas
            id="previewCanvas"
            width="1080"
            height="1920"
            aria-label="Shorts Preview"
          ></canvas>
        </div>

        <div class="preview-controls">
          <div class="preview-buttons">
            <button id="previewPlayBtn" class="btn ghost">Load & Play</button>
            <button id="previewStopBtn" class="btn ghost">Stop</button>
          </div>

          <!-- ‚úÖ ADD: Volume control row -->
          <div class="preview-volume">
            <label for="volumeSlider" class="small" style="color: var(--muted)"
              >Volume</label
            >
            <input
              id="volumeSlider"
              type="range"
              min="0"
              max="100"
              value="100"
            />
            <span id="volumeVal" class="small" style="color: var(--muted)"
              >100%</span
            >
          </div>

          <div id="audioErrorMessage" class="audio-error-message"></div>
        </div>
        <style>
          .preview-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            width: 100%;
          }
          .preview-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 100%;
          }
          .preview-volume {
            /* ‚úÖ ADD */
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            width: 100%;
          }
          #volumeSlider {
            /* ‚úÖ ADD */
            width: 220px;
          }
          .audio-error-message {
            color: #856404;
            font-size: 14px;
            display: none;
            text-align: center;
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 auto;
          }
        </style>

        <audio
          id="audioPlayer"
          controls
          preload="metadata"
          style="display: none"
        ></audio>
        <a
          href="https://theaaa-studio.github.io/AAA_Personal_Portfolio/"
          target="_blank"
          class="version-info"
        >
          Version 1.0 ‚Ä¢ <span class="dev-name">Developed by TheAAA</span> ‚Ä¢ 2025
        </a>

        <style>
          .version-info {
            text-decoration: none;
            color: inherit;
          }
          .version-info .dev-name {
            text-decoration: underline;
          }
          #audioPlayer {
            display: none;
          }
        </style>
      </main>
    </div>

    <script>
      // ------------------ Utils ------------------
      const $ = (s) => document.querySelector(s);
      const pad3 = (n) => String(Number(n) || 0).padStart(3, "0");
      const safe = (s) => (s || "").replace(/[^\w-]+/g, "_");
      const timestampStr = (d = new Date()) => {
        const z = (n) => String(n).padStart(2, "0");
        return `${d.getFullYear()}${z(d.getMonth() + 1)}${z(d.getDate())}_${z(
          d.getHours()
        )}${z(d.getMinutes())}${z(d.getSeconds())}`;
      };

      async function fetchRetry(url, opts = {}, retries = 2) {
        for (let i = 0; i <= retries; i++) {
          try {
            const res = await fetch(url, { cache: "no-store", ...opts });
            if (!res.ok) throw new Error(res.status + " " + res.statusText);
            return res;
          } catch (e) {
            if (i === retries) throw e;
            await new Promise((r) => setTimeout(r, 500 * (i + 1)));
          }
        }
      }

      // ------------------ DOM ------------------
      const reciterSel = $("#reciter");
      const surahSel = $("#surah");
      const ayahStartSel = $("#ayahStart");
      const ayahEndSel = $("#ayahEnd");
      const fontPicker = $("#fontPicker");
      const textSize = $("#textSize");
      const textSizeVal = $("#textSizeVal");

      const bgColorInput = $("#bgColor");
      const fontColorInput = $("#fontColor");

      const translationEditionSel = $("#translationEdition");

      const creditDataChk = $("#creditData");
      const creditCreatorChk = $("#creditCreator");
      const madeByInput = $("#madeByInput");
      const creditMadeByChk = $("#creditMadeBy");

      const bgModeColor = $("#bgModeColor");
      const bgModeMedia = $("#bgModeMedia");
      const bgColorField = $("#bgColorField");
      const bgMediaField = $("#bgMediaField");
      const bgMediaSelect = $("#bgMediaSelect");
      const bgMediaHint = $("#bgMediaHint");
      const bgUploadInput = $("#bgUploadInput");

      const previewCanvas = $("#previewCanvas");
      const pctx = previewCanvas.getContext("2d");

      const buildPreviewBtn = $("#buildPreviewBtn");
      const downloadBtn = $("#downloadBtn");
      const previewPlayBtn = $("#previewPlayBtn");
      const dismissBtn = $("#dismissBtn");

      // Volume UI
      const volumeSlider = $("#volumeSlider");
      const volumeVal = $("#volumeVal");

      const audio = $("#audioPlayer");
      const recStatus = $("#recStatus");
      const meterBar = $("#meterBar");
      audio.crossOrigin = "anonymous";

      // ------------------ State ------------------
      let meta = { surahs: [] };
      let playlist = [];
      let index = 0;
      let isPlaying = false;

      // text controls
      let selectedFont = "Inter, sans-serif";
      let sizePercent = 100; // 25‚Äì160
      let translationEdition = "en.asad";

      // drawing content
      let currentText = "Centered translation will appear here.";
      let currentLabel = "‚Äî";

      // Background state
      let backgroundMode = "color"; // 'color' | 'media'
      let bgColor = "#ffffff";
      let fontColor = "#111111";
      let bgMediaList = []; // [{src, type, name?}]
      let selectedBg = null; // active media item
      const bgImg = new Image();
      bgImg.crossOrigin = "anonymous";
      const bgVideo = document.createElement("video");
      bgVideo.loop = true;
      bgVideo.muted = true;
      bgVideo.playsInline = true;
      bgVideo.crossOrigin = "anonymous";

      // credits
      let showCreditData = true;
      let showCreditCreator = true;

      // recording state
      let audioCtx = null,
        srcNode = null,
        gainNode = null,
        destNode = null,
        mixedStream = null,
        connections = { toDest: false, toRecorder: false };

      let recorder = null;
      let chunks = [];
      let recordingStarted = false;
      let finalBlob = null;
      let hasAudioError = false;
      let wasDismissed = false;

      // gate: only record when explicitly allowed
      let allowRecording = true;

      // progress
      let totalAyahs = 0;

      // session info for filename
      let sessionSurah = 1,
        sessionSurahName = "Al-Fatihah",
        sessionFrom = 1,
        sessionTo = 1,
        sessionReciterName = "Unknown";

      // ------------------ UI toggle helper ------------------
      function setDuringRecordingUI(active) {
        const stopBtn = document.getElementById("previewStopBtn");
        if (dismissBtn) dismissBtn.disabled = !active;
        if (previewPlayBtn) previewPlayBtn.disabled = !!active;
        if (stopBtn) stopBtn.disabled = !!active;
      }

      // ------------------ Change handling ------------------
      function resetSessionUI() {
        try {
          if (recorder && recorder.state === "recording") recorder.stop();
        } catch {}
        recorder = null;
        recordingStarted = false;
        chunks = [];
        finalBlob = null;
        downloadBtn.disabled = true;
        recStatus.textContent =
          "Press Play & Export to preview & auto-record. Avoid the right audio controller during recording.";
        meterBar.style.width = "0%";
        setDuringRecordingUI(false);
      }

      function onAnyInputChange() {
        resetSessionUI();
        selectedFont = fontPicker.value;
        sizePercent = parseInt(textSize.value, 10) || 100;
        if (textSizeVal) textSizeVal.textContent = `(${sizePercent}%)`;
        if (bgColorInput) bgColor = bgColorInput.value;
        if (fontColorInput) fontColor = fontColorInput.value;
        translationEdition = translationEditionSel?.value || "en.asad";
        showCreditData = !!creditDataChk?.checked;
        showCreditCreator = !!creditCreatorChk?.checked;
      }

      [
        reciterSel,
        surahSel,
        ayahStartSel,
        ayahEndSel,
        fontPicker,
        textSize,
        creditDataChk,
        creditCreatorChk,
        bgColorInput,
        fontColorInput,
        translationEditionSel,
      ]
        .filter(Boolean)
        .forEach((el) => {
          el.addEventListener("change", onAnyInputChange);
          if (el === textSize) {
            el.addEventListener("input", () => {
              sizePercent = parseInt(textSize.value, 10) || 100;
              if (textSizeVal) textSizeVal.textContent = `(${sizePercent}%)`;
            });
          }
        });

      // Color preview
      bgColorInput?.addEventListener("input", () => {
        bgColor = bgColorInput.value;
      });
      fontColorInput?.addEventListener("input", () => {
        fontColor = fontColorInput.value;
      });

      // ------------------ Background mode toggles ------------------
      function applyBgModeUI() {
        if (backgroundMode === "color") {
          bgColorField.style.display = "block";
          bgMediaField.style.display = "none";
        } else {
          bgColorField.style.display = "none";
          bgMediaField.style.display = "block";
        }
      }
      bgModeColor?.addEventListener("change", () => {
        if (bgModeColor.checked) {
          backgroundMode = "color";
          applyBgModeUI();
        }
      });
      bgModeMedia?.addEventListener("change", async () => {
        if (bgModeMedia.checked) {
          backgroundMode = "media";
          applyBgModeUI();
          if (!bgMediaList.length) await loadBackgroundAssets();
        }
      });

      // ------------------ Metadata ------------------
      async function loadMeta() {
        try {
          const m = await (
            await fetchRetry("https://api.alquran.cloud/v1/meta")
          ).json();
          const e = await (
            await fetchRetry("https://api.quran.com/api/v4/chapters")
          ).json();
          const chapters = Array.isArray(e?.chapters) ? e.chapters : [];
          const engById = new Map(chapters.map((c) => [c.id, c]));
          const refs = m?.data?.surahs?.references || [];
          meta.surahs = refs.map((s) => ({
            number: s.number,
            nameAr: s.name,
            englishName:
              engById.get(s.number)?.name_simple || s.englishName || s.name,
            ayahCount: s.numberOfAyahs,
          }));
          if (!meta.surahs.length) throw new Error("Surah metadata missing");

          surahSel.innerHTML = meta.surahs
            .map(
              (s) =>
                `<option value="${s.number}">${s.number}. ${s.englishName} (${s.nameAr})</option>`
            )
            .join("");
          updateAyahRange();
        } catch (err) {
          console.error(err);
        }
      }

      function updateAyahRange() {
        const sNum = +surahSel.value || 1;
        const s = meta.surahs.find((x) => x.number === sNum) || meta.surahs[0];
        if (!s) return;
        const opts = Array.from(
          { length: s.ayahCount },
          (_, i) => `<option value="${i + 1}">Ayah ${i + 1}</option>`
        ).join("");
        ayahStartSel.innerHTML = opts;
        ayahEndSel.innerHTML = opts;
        ayahStartSel.value = "1";
        ayahEndSel.value = String(Math.min(5, s.ayahCount));
        sessionSurahName = s.englishName;

        const handler = () => {
          if (+ayahEndSel.value < +ayahStartSel.value)
            ayahEndSel.value = ayahStartSel.value;
        };
        ayahStartSel.addEventListener("change", handler, { once: true });
        onAnyInputChange();
      }
      surahSel.addEventListener("change", updateAyahRange);

      // ------------------ Background assets (simplified) ------------------
      const ALLOWED_EXT = [
        "png",
        "jpg",
        "jpeg",
        "gif",
        "bmp",
        "webp",
        "avif",
        "mp4",
        "webm",
        "mov",
        "m4v",
      ];
      function inferTypeFromPath(src) {
        const l = (src || "").toLowerCase();
        return ["mp4", "webm", "mov", "m4v"].some((e) => l.endsWith("." + e))
          ? "video"
          : "image";
      }

      function populateSelectFromList(list) {
        const combined = [
          ...userUploads,
          ...(list || []).filter(
            (it) => it.src && (it.type === "image" || it.type === "video")
          ),
        ];

        bgMediaList = combined;

        if (!bgMediaList.length) {
          bgMediaSelect.innerHTML = "";
          bgMediaHint.textContent =
            "No media configured. Upload to get started.";
          bgMediaSelect.disabled = true;
          selectedBg = null;
          return;
        }

        bgMediaSelect.innerHTML = bgMediaList
          .map(
            (it, i) =>
              `<option value="${i}">${it.type === "video" ? "üéûÔ∏è" : "üñºÔ∏è"} ${
                it.name || it.src
              }</option>`
          )
          .join("");

        bgMediaSelect.disabled = false;
        bgMediaHint.textContent = `Available: ${bgMediaList.length} item(s). ${
          userUploads.length ? `(${userUploads.length} from your uploads)` : ""
        }`;
        if (bgMediaSelect.value === "" || bgMediaSelect.value == null) {
          bgMediaSelect.value = "0";
        }
        onBgMediaChange();
      }

      function handleUserFiles(fileList) {
        if (!fileList || !fileList.length) return;

        revokeUserUploadURLs();
        userUploads = [];

        for (const f of fileList) {
          const url = URL.createObjectURL(f);
          const isVideo = (f.type || "").startsWith("video");
          const isImage = (f.type || "").startsWith("image");
          if (!isVideo && !isImage) continue;

          userUploads.push({
            src: url,
            type: isVideo ? "video" : "image",
            name: `üì• ${f.name}`,
            __blobUrl: true,
          });
        }

        populateSelectFromList(bgMediaList);
        if (bgModeMedia && !bgModeMedia.checked) {
          bgModeMedia.checked = true;
          backgroundMode = "media";
          applyBgModeUI();
        }

        if (userUploads.length) {
          const firstUploadIndex = 0;
          bgMediaSelect.value = String(firstUploadIndex);
          onBgMediaChange();
        }
      }

      bgUploadInput?.addEventListener("change", (e) => {
        handleUserFiles(e.target.files);
      });

      let userUploads = []; // [{ src, type, name, __blobUrl: true }]
      function revokeUserUploadURLs() {
        for (const item of userUploads) {
          if (item.__blobUrl && item.src) {
            try {
              URL.revokeObjectURL(item.src);
            } catch {}
          }
        }
      }
      window.addEventListener("beforeunload", revokeUserUploadURLs);

      const DEFAULT_BG_MEDIA = []; // fallback (optional)

      async function loadBackgroundAssets() {
        try {
          bgMediaHint.textContent = "Loading background.json‚Ä¶";
          const res = await fetchRetry("assets/background/background.json");
          const raw = await res.json();

          const normalized = (Array.isArray(raw) ? raw : [])
            .map((it) => {
              const src = it && it.src ? String(it.src) : "";
              const ext = src.split(".").pop()?.toLowerCase() || "";
              if (!ALLOWED_EXT.includes(ext)) return null;
              return {
                src,
                name: it.name || src.split("/").pop(),
                type: it.type ? it.type : inferTypeFromPath(src),
              };
            })
            .filter(Boolean);

          if (!normalized.length) {
            if (DEFAULT_BG_MEDIA.length) {
              bgMediaHint.textContent = "No items in JSON; using defaults.";
              populateSelectFromList(DEFAULT_BG_MEDIA);
            } else {
              bgMediaHint.textContent = "No items found in background.json.";
              populateSelectFromList([]);
            }
            return;
          }

          populateSelectFromList(normalized);
          bgMediaHint.textContent = "Loaded";
        } catch (e) {
          console.warn("Failed to load background.json:", e);
          if (DEFAULT_BG_MEDIA.length) {
            bgMediaHint.textContent = "Failed to load JSON; using defaults.";
            populateSelectFromList(DEFAULT_BG_MEDIA);
          } else {
            bgMediaHint.textContent = "Failed to load background.json.";
            populateSelectFromList([]);
          }
        }
      }

      function onBgMediaChange() {
        const idx = parseInt(bgMediaSelect.value, 10);
        selectedBg = bgMediaList[idx] || null;
        if (!selectedBg) return;
        if (selectedBg.type === "image") {
          bgImg.onload = () => {};
          bgImg.src = selectedBg.src;
        } else {
          try {
            bgVideo.src = selectedBg.src;
            bgVideo.load();
            bgVideo.play().catch(() => {});
          } catch {}
        }
      }
      bgMediaSelect.addEventListener("change", onBgMediaChange);

      // ------------------ Text layout + drawing ------------------
      function fitTextToBox(
        ctx,
        text,
        maxW,
        maxH,
        startSize,
        minSize,
        lhRatio,
        fontFamily,
        weight = 700
      ) {
        let size = startSize;
        while (size >= minSize) {
          const lines = wrapText(
            ctx,
            text,
            weight + " " + size + "px " + fontFamily,
            maxW
          );
          const lineH = Math.round(size * lhRatio);
          const totalH = lines.length * lineH;
          if (totalH <= maxH)
            return { fontSize: size, lines, lineHeight: lineH };
          size -= 2;
        }
        return {
          fontSize: minSize,
          lines: wrapText(
            ctx,
            text,
            weight + " " + minSize + "px " + fontFamily,
            maxW
          ),
          lineHeight: Math.round(minSize * lhRatio),
        };
      }
      function wrapText(ctx, text, font, maxW) {
        ctx.font = font;
        const words = String(text || "")
          .trim()
          .split(/\s+/);
        const lines = [];
        let cur = "";
        for (const w of words) {
          const t = cur ? cur + " " + w : w;
          if (ctx.measureText(t).width <= maxW) cur = t;
          else {
            if (cur) lines.push(cur);
            if (ctx.measureText(w).width > maxW) {
              let buf = "";
              for (const ch of w) {
                const test = buf + ch;
                if (ctx.measureText(test).width <= maxW) buf = test;
                else {
                  lines.push(buf);
                  buf = ch;
                }
              }
              cur = buf;
            } else cur = w;
          }
        }
        if (cur) lines.push(cur);
        return lines;
      }
      function drawRoundedRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.lineTo(x + w - rr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
        ctx.lineTo(x + w, y + h - rr);
        ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
        ctx.lineTo(x + rr, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
        ctx.lineTo(x, y + rr);
        ctx.quadraticCurveTo(x, y, x + rr, y);
        ctx.closePath();
      }
      function drawMediaCover(ctx, mediaEl, W, H) {
        const mw = mediaEl.videoWidth || mediaEl.naturalWidth;
        const mh = mediaEl.videoHeight || mediaEl.naturalHeight;
        if (!mw || !mh) return false;
        const canvasAR = W / H;
        const mediaAR = mw / mh;
        let dw, dh, dx, dy;
        if (mediaAR > canvasAR) {
          dh = H;
          dw = H * mediaAR;
          dx = (W - dw) / 2;
          dy = 0;
        } else {
          dw = W;
          dh = W / mediaAR;
          dx = 0;
          dy = (H - dh) / 2;
        }
        ctx.drawImage(mediaEl, dx, dy, dw, dh);
        return true;
      }
      function drawPreview() {
        const W = previewCanvas.width,
          H = previewCanvas.height;

        // Background
        if (backgroundMode === "media" && selectedBg) {
          let drew = false;
          if (
            selectedBg.type === "image" &&
            bgImg.complete &&
            bgImg.naturalWidth
          ) {
            drew = drawMediaCover(pctx, bgImg, W, H);
          } else if (selectedBg.type === "video" && bgVideo.readyState >= 2) {
            drew = drawMediaCover(pctx, bgVideo, W, H);
          }
          if (!drew) {
            pctx.fillStyle = bgColor;
            pctx.fillRect(0, 0, W, H);
          }
        } else {
          pctx.fillStyle = bgColor;
          pctx.fillRect(0, 0, W, H);
        }

        // Text
        const marginX = 90,
          marginY = 180;
        const usableW = W - 2 * marginX,
          usableH = H - 2 * marginY;
        const scale = (sizePercent || 100) / 100;
        const spec = fitTextToBox(
          pctx,
          currentText,
          usableW,
          usableH,
          72 * scale,
          34 * scale,
          1.25,
          selectedFont,
          700
        );
        const { fontSize, lines, lineHeight } = spec;

        pctx.fillStyle = fontColor;
        pctx.textAlign = "center";
        pctx.textBaseline = "middle";
        pctx.font = `700 ${fontSize}px ${selectedFont}`;
        const totalH = lines.length * lineHeight;
        let y = H / 2 - totalH / 2;
        pctx.save();
        pctx.shadowColor = "rgba(0,0,0,0.14)";
        pctx.shadowBlur = 8;
        lines.forEach((ln, i) => pctx.fillText(ln, W / 2, y + i * lineHeight));
        pctx.restore();

        // Bottom label
        pctx.font = `600 ${Math.max(
          30,
          Math.round(36 * scale)
        )}px ${selectedFont}`;
        pctx.fillStyle = fontColor;
        pctx.textAlign = "right";
        pctx.fillText(currentLabel, W - 40, H - 60);

        // Credits
        const badgePadX = 14,
          badgePadY = 10,
          badgeRadius = 14;
        pctx.textAlign = "left";
        pctx.textBaseline = "alphabetic";
        const creditTextColor = fontColor;

        if (showCreditCreator) {
          const txt = "Quran Shorts ‚Äî Editor by TheAAA";
          pctx.font = `600 18px ${selectedFont}`;
          const tw = pctx.measureText(txt).width;
          const th = 24;
          const bx = 40,
            by = 60;
          pctx.save();
          pctx.globalAlpha = 0.12;
          pctx.fillStyle = "#000";
          drawRoundedRect(
            pctx,
            bx - badgePadX,
            by - th - badgePadY + 6,
            tw + badgePadX * 2,
            th + badgePadY * 2,
            badgeRadius
          );
          pctx.fill();
          pctx.restore();
          pctx.fillStyle = creditTextColor;
          pctx.fillText(txt, bx, by);
        }

        const madeByNameNow = (madeByInput?.value || "").trim();
        const showMadeByNow = !!creditMadeByChk?.checked;
        if (showMadeByNow && madeByNameNow) {
          pctx.font = `600 18px ${selectedFont}`;
          let txt = `Made by ${madeByNameNow}`;
          const th = 24;
          const bx = W - 40,
            by = 60;
          while (pctx.measureText(txt).width > W - 120 && txt.length > 4) {
            txt = txt.slice(0, -4) + "‚Ä¶";
          }
          const tw = pctx.measureText(txt).width;
          pctx.save();
          pctx.globalAlpha = 0.12;
          pctx.fillStyle = "#000";
          drawRoundedRect(
            pctx,
            bx - tw - badgePadX,
            by - th - badgePadY + 6,
            tw + badgePadX * 2,
            th + badgePadY * 2,
            badgeRadius
          );
          pctx.fill();
          pctx.restore();
          pctx.fillStyle = creditTextColor;
          pctx.textAlign = "right";
          pctx.fillText(txt, bx, by);
          pctx.textAlign = "left";
        }

        if (showCreditData) {
          let txt = "Data: Quran.com & AlQuran Cloud ‚Ä¢ Audio: EveryAyah.com";
          pctx.font = `600 18px ${selectedFont}`;
          const th = 24;
          const bx = 40,
            by = H - 60;
          while (pctx.measureText(txt).width > W - 120 && txt.length > 4) {
            txt = txt.slice(0, -4) + "‚Ä¶";
          }
          const tw = pctx.measureText(txt).width;
          pctx.save();
          pctx.globalAlpha = 0.12;
          pctx.fillStyle = "#000";
          drawRoundedRect(
            pctx,
            bx - badgePadX,
            by - th - badgePadY + 6,
            tw + badgePadX * 2,
            th + badgePadY * 2,
            badgeRadius
          );
          pctx.fill();
          pctx.restore();
          pctx.fillStyle = creditTextColor;
          pctx.fillText(txt, bx, by);
        }

        requestAnimationFrame(drawPreview);
      }

      // ------------------ Volume helpers ------------------
      function setVolumeFromSlider() {
        const v = Math.max(0, Math.min(100, Number(volumeSlider?.value) || 0));
        if (volumeVal) volumeVal.textContent = `${v}%`;
        audio.volume = v / 100; // playback loudness
        if (gainNode) gainNode.gain.value = v / 100; // recorded loudness
      }

      // ------------------ Audio graph + routing ------------------
      function ensureAudioGraph() {
        if (audioCtx) return true;
        try {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return false;
          audioCtx = new AC();
          srcNode = audioCtx.createMediaElementSource(audio);
          gainNode = audioCtx.createGain();
          destNode = audioCtx.createMediaStreamDestination();

          // Start with slider value
          gainNode.gain.value = (Number(volumeSlider?.value) || 100) / 100;

          // Base connection
          srcNode.connect(gainNode);

          // We'll route to speakers/recorder via updateAudioRouting()
          connections = { toDest: false, toRecorder: false };
          updateAudioRouting();

          return true;
        } catch (e) {
          console.warn("Audio graph unavailable (CORS or browser):", e);
          audioCtx = null;
          srcNode = null;
          gainNode = null;
          destNode = null;
          // Fallback: element audio will be heard
          // audio.muted = false;
          audio.volume = (Number(volumeSlider?.value) || 100) / 100;
          return false;
        }
      }

      // Replace your entire updateAudioRouting() with this:
      function updateAudioRouting() {
        if (!gainNode || !audioCtx) return;

        // Safely connect/disconnect helpers
        const connect = (node, target) => {
          try {
            node.connect(target);
          } catch (_) {}
        };
        const disconnect = (node, target) => {
          try {
            node.disconnect(target);
          } catch (_) {}
        };

        // Reset previous routes
        if (audioCtx.destination) disconnect(gainNode, audioCtx.destination);
        if (destNode) disconnect(gainNode, destNode);

        // Always monitor to speakers
        if (audioCtx.destination) connect(gainNode, audioCtx.destination);

        // Additionally feed the recorder only when recording
        if (allowRecording && destNode) connect(gainNode, destNode);
      }

      async function ensureGraphOnGesture() {
        if (!audioCtx) {
          const ok = ensureAudioGraph();
          if (!ok) {
            // audio.muted = false;
            return false;
          }
        }
        if (audioCtx.state === "suspended") {
          try {
            await audioCtx.resume();
          } catch {}
        }
        // Always keep element audible
        // audio.muted = false;
        return true;
      }

      // ------------------ Recording setup ------------------
      function buildMixedStream() {
        const fps = 30;
        const canvasStream = previewCanvas.captureStream(fps);
        const ok = ensureAudioGraph();
        if (ok && destNode) {
          return new MediaStream([
            ...canvasStream.getVideoTracks(),
            ...destNode.stream.getAudioTracks(),
          ]);
        }
        // Fallback: no audio track if WebAudio not available/CORS-blocked
        return new MediaStream([...canvasStream.getTracks()]);
      }

      function pickMime() {
        const candidates = [
          "video/webm;codecs=vp9,opus",
          "video/webm;codecs=vp8,opus",
          "video/webm",
        ];
        for (const m of candidates) {
          if (
            window.MediaRecorder &&
            MediaRecorder.isTypeSupported &&
            MediaRecorder.isTypeSupported(m)
          )
            return m;
        }
        return "";
      }

      function initRecorder() {
        if (recorder) return;
        mixedStream = buildMixedStream();
        const mime = pickMime();
        try {
          recorder = new MediaRecorder(mixedStream, {
            ...(mime ? { mimeType: mime } : {}),
            videoBitsPerSecond: 5_000_000,
          });
        } catch (e) {
          console.error("MediaRecorder init failed:", e);
          return;
        }
        chunks = [];
        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size) chunks.push(e.data);
        };
        recorder.onstart = () => {
          recStatus.textContent = "Recording in the background‚Ä¶";
        };
        recorder.onstop = () => {
          finalBlob = new Blob(chunks, { type: mime || "video/webm" });

          if (!hasAudioError && !wasDismissed) {
            downloadBtn.disabled = false;
            recStatus.textContent =
              "Recording complete. You can download your Short.";
          } else {
            downloadBtn.disabled = true;
            recStatus.textContent = wasDismissed
              ? "Dismissed. Ready."
              : "Recording incomplete due to audio error. Download disabled.";
          }

          setDuringRecordingUI(false);
        };
      }

      function startRecordingIfNeeded() {
        if (!allowRecording) return;

        // Ensure recorder path is connected
        if (audioCtx && gainNode) updateAudioRouting();

        if (!recorder) initRecorder();
        if (!recorder) return;
        if (!recordingStarted && recorder.state !== "recording") {
          try {
            recorder.start();
            recordingStarted = true;
            recStatus.textContent = "Recording in the background‚Ä¶";
          } catch (e) {
            console.error(e);
            recStatus.textContent =
              "Recording failed to start. Check browser permissions.";
          }
        }
      }
      function stopRecordingIfActive() {
        if (recorder && recorder.state === "recording") {
          try {
            recorder.stop();
          } catch {}
        }
      }

      // ------------------ Playback controls ------------------
      async function loadAndPlay({ record }) {
        // Mode flag
        allowRecording = !!record;

        // UI & flags
        resetSessionUI();
        setDuringRecordingUI(!!record);
        wasDismissed = false;
        hasAudioError = false;

        // Clear any prior audio error banner
        const errorMessage = $("#audioErrorMessage");
        if (errorMessage) {
          errorMessage.textContent = "";
          errorMessage.style.display = "none";
        }

        // Ensure WebAudio, wire routes, apply current volume (no muting anywhere)
        await ensureGraphOnGesture();
        updateAudioRouting();
        setVolumeFromSlider(); // sets audio.volume and gainNode.gain to slider %

        // Recorder buffers
        stopRecordingIfActive();
        recordingStarted = false;
        chunks = [];
        finalBlob = null;
        downloadBtn.disabled = true;

        // ---- Read selections ----
        sessionSurah = +surahSel.value || 1;
        const s =
          meta.surahs.find((x) => x.number === sessionSurah) || meta.surahs[0];
        sessionSurahName = s?.englishName || "Unknown";
        sessionFrom = +ayahStartSel.value || 1;
        sessionTo = +ayahEndSel.value || Math.min(5, s?.ayahCount || 5);
        sessionReciterName =
          reciterSel.options[reciterSel.selectedIndex]?.text || "Unknown";

        selectedFont = fontPicker.value;
        sizePercent = parseInt(textSize.value, 10) || 100;
        translationEdition = translationEditionSel?.value || "en.asad";
        showCreditData = !!creditDataChk?.checked;
        showCreditCreator = !!creditCreatorChk?.checked;
        backgroundMode = bgModeMedia.checked ? "media" : "color";

        // ---- Validate ----
        if (
          !s ||
          Number.isNaN(sessionFrom) ||
          Number.isNaN(sessionTo) ||
          sessionFrom < 1 ||
          sessionTo > s.ayahCount ||
          sessionFrom > sessionTo
        ) {
          recStatus.textContent =
            "Invalid ayah range. Please adjust the selection.";
          setDuringRecordingUI(false);
          return;
        }

        // ---- Playlist ----
        playlist = [];
        for (let a = sessionFrom; a <= sessionTo; a++) {
          playlist.push({ surah: sessionSurah, ayah: a, sName: s.englishName });
        }
        index = 0;
        totalAyahs = playlist.length;

        meterBar.style.width = "0%";
        await playIndex(index, true);
      }

      buildPreviewBtn.addEventListener("click", async () => {
        await ensureGraphOnGesture();
        allowRecording = true;
        updateAudioRouting();
        setVolumeFromSlider();
        loadAndPlay({ record: true });
      });

      previewPlayBtn.addEventListener("click", async () => {
        await ensureGraphOnGesture();
        allowRecording = false;
        updateAudioRouting();
        setVolumeFromSlider();
        loadAndPlay({ record: false });
      });

      // Stop button
      const previewStopBtn = $("#previewStopBtn");
      previewStopBtn.addEventListener("click", () => {
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
          index = 0;
          updateMeter();
          isPlaying = false;
          if (recorder && recorder.state === "recording") {
            stopRecordingIfActive();
          }
        }
      });

      function updateMeter() {
        if (!totalAyahs) {
          meterBar.style.width = "0%";
          return;
        }
        const denom = Math.max(1, totalAyahs - 1);
        const pct = Math.min(100, Math.round((index / denom) * 100));
        meterBar.style.width = pct + "%";
      }

      audio.addEventListener("play", async () => {
        isPlaying = true;
        await ensureGraphOnGesture();
        updateAudioRouting();
        if (allowRecording) startRecordingIfNeeded();
      });
      audio.addEventListener("pause", () => {
        isPlaying = false;
      });
      audio.addEventListener("ended", async () => {
        if (index < playlist.length - 1) {
          index++;
          updateMeter();
          await playIndex(index, true);
        } else {
          isPlaying = false;
          updateMeter();
          stopRecordingIfActive();
        }
      });

      async function playIndex(i, autoplay = false) {
        const it = playlist[i];
        if (!it) return;
        const s3 = pad3(it.surah),
          a3 = pad3(it.ayah);

        try {
          const tRes = await fetchRetry(
            `https://api.alquran.cloud/v1/ayah/${it.surah}:${it.ayah}/${translationEdition}`
          );
          const t = await tRes.json();
          currentText =
            t && t.code === 200 && t.data && t.data.text
              ? t.data.text
              : "(Translation unavailable)";
        } catch {
          currentText = "(Failed to load translation)";
        }

        currentLabel = `${it.sName} ‚Ä¢ Ayah ${it.ayah}`;
        const reciter = reciterSel.value;
        const audioUrl = `https://everyayah.com/data/${reciter}/${s3}${a3}.mp3`;

        // Hide any previous error message
        const errorMessage = $("#audioErrorMessage");
        errorMessage.style.display = "none";

        // Audio error handling
        audio.onerror = () => {
          const errorMessage = $("#audioErrorMessage");
          errorMessage.textContent = `‚ö†Ô∏è Failed to load audio for Surah ${it.surah}, Ayah ${it.ayah}`;
          errorMessage.style.display = "block";

          hasAudioError = true;

          if (recorder && recorder.state === "recording") {
            try {
              recorder.stop();
            } catch {}
            chunks = [];
            finalBlob = null;
          }

          recordingStarted = false;
          recorder = null;
          downloadBtn.disabled = true;
          isPlaying = false;

          recStatus.textContent = "Recording stopped due to audio error.";
          setDuringRecordingUI(false);
        };

        audio.src = audioUrl;

        if (!recorder && allowRecording) initRecorder();
        if (autoplay) {
          try {
            await audio.play();
          } catch (err) {
            console.warn("audio.play() was blocked:", err);
            const errorMessage = $("#audioErrorMessage");
            if (errorMessage) {
              errorMessage.textContent = `‚ö†Ô∏è Failed to load audio for Surah ${it.surah}, Ayah ${it.ayah}`;
              errorMessage.style.display = "block";
            }
          }
        }
      }

      // ------------------ Download recorded WebM ------------------
      downloadBtn.addEventListener("click", () => {
        if (!finalBlob) return;
        const ts = timestampStr();
        const filename = `Surah-${sessionSurah}-${safe(
          sessionSurahName
        )}_Ayah-${sessionFrom}-${sessionTo}_${safe(
          sessionReciterName
        )}_${ts}.webm`;
        const url = URL.createObjectURL(finalBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
          a.remove();
        }, 1000);
      });

      // ------------------ Dismiss behavior ------------------
      dismissBtn?.addEventListener("click", () => {
        wasDismissed = true;
        try {
          if (audio) {
            audio.pause();
            audio.currentTime = 0;
          }
          stopRecordingIfActive();
        } catch {}
        chunks = [];
        finalBlob = null;
        downloadBtn.disabled = true;
        recStatus.textContent = "Dismissed. Ready.";
        setDuringRecordingUI(false);
      });

      // ------------------ Volume slider wiring ------------------
      volumeSlider?.addEventListener("input", async () => {
        await ensureGraphOnGesture();
        setVolumeFromSlider();
        // routing unchanged, element remains audible
      });

      // ------------------ Init ------------------
      (async () => {
        await loadMeta();
        selectedFont = fontPicker.value;
        sizePercent = parseInt(textSize.value, 10) || 100;
        if (textSizeVal) textSizeVal.textContent = `(${sizePercent}%)`;
        bgColor = bgColorInput.value;
        fontColor = fontColorInput.value;
        translationEdition = translationEditionSel?.value || "en.asad";
        showCreditData = !!creditDataChk?.checked;
        showCreditCreator = !!creditCreatorChk?.checked;
        applyBgModeUI();
        await loadBackgroundAssets();
        setDuringRecordingUI(false);

        // Volume UI defaults
        if (volumeVal) volumeVal.textContent = `${volumeSlider?.value || 100}%`;
        audio.volume = (Number(volumeSlider?.value) || 100) / 100;
        // audio.muted = false; // ensure always audible

        requestAnimationFrame(drawPreview);
      })();
    </script>
  </body>
</html>
